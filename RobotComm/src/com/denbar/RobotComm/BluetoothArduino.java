package com.denbar.RobotComm;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Set;
import java.util.UUID;

import android.app.Service;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothSocket;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Handler;
import android.os.IBinder;
import android.util.Log;

public class BluetoothArduino extends Service
{
	private BluetoothDevice _bluetoothTarget;
	private BluetoothAdapter _bluetoothAdapter;
	private BluetoothSocket _socket;
	private OutputStream _outputStream;
	private InputStream _inputStream;
	Thread workerThread;
	byte[] readBuffer;
	int readBufferPosition;
	int counter;
	volatile boolean stopWorker;
	//final Context _context = RobotCommApplication.getInstance().getApplicationContext();
	//UUID generated from UUID generator website:
	//private UUID uuid = UUID.fromString("a60f35f0-b93a-11de-8a39-08002009c666");
	//Actual Unique UUID for this application generated by Android: fa87c0d0-afac-11de-8a39-0800200c9a66
	//common machine UUID that we need to communicate with FireFly Bluetooth module: 00001101-0000-1000-8000-00805F9B34FB
	// http://developer.android.com/reference/android/bluetooth/BluetoothDevice.html#createRfcommSocketToServiceRecord%28java.util.UUID%29
	// If you are connecting to a Bluetooth serial board then try using the well-known SPP UUID 00001101-0000-1000-8000-00805F9B34FB
	// However if you are connecting to an Android peer then please generate your own unique UUID.
	private static final UUID uuid = UUID.fromString("00001101-0000-1000-8000-00805F9B34FB");
	//private String bluetoothAddress;

	@Override
	public void onDestroy() {
        //_context.unregisterReceiver(dataForArduino);
		this.unregisterReceiver(bluetoothEvent);
		this.unregisterReceiver(dataForArduino);
        try
        {
            closeBT();
        }
        catch (IOException ex) { }
	}

	@Override
	public void onCreate() {
		super.onCreate();
		RobotCommApplication.getInstance().setBluetoothConnected(false);
	    IntentFilter IncomingRobotCommand = new IntentFilter("com.BluetoothArduino.SEND_TO_ARDUINO");
	    IntentFilter filter1 = new IntentFilter(BluetoothDevice.ACTION_ACL_CONNECTED);
	    IntentFilter filter2 = new IntentFilter(BluetoothDevice.ACTION_ACL_DISCONNECT_REQUESTED);
	    IntentFilter filter3 = new IntentFilter(BluetoothDevice.ACTION_ACL_DISCONNECTED);
	    this.registerReceiver(bluetoothEvent, filter1);
	    this.registerReceiver(bluetoothEvent, filter2);
	    this.registerReceiver(bluetoothEvent, filter3);
	    this.registerReceiver(dataForArduino, IncomingRobotCommand);
		init();
	}

	@Override
	public int onStartCommand(Intent intent, int flags, int startId)
	{
		if (init()) RobotCommApplication.getInstance().setBluetoothConnected(true);
		else RobotCommApplication.getInstance().setBluetoothConnected(false);
		return Service.START_STICKY; // service will restart after being terminated by the runtime
	}

	private boolean init()
	{
		 try
		{
			if (!findBT()) return false;
			openBT();
		}
		catch (IOException ex) {
			return false;
		}
		ListenForData();
		return true;
	}

	private boolean findBT() throws IOException
	{
		if (_bluetoothTarget != null)
		{
			if (_bluetoothTarget.getBondState() == BluetoothDevice.BOND_BONDED) return true;
		}
		_bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
		if(_bluetoothAdapter == null)
		{
			return false;
		}
		if (!_bluetoothAdapter.isEnabled())
		{
			if (!_bluetoothAdapter.enable())
			{
				return false;
			}
		}

		int counter = 0;
		while (_bluetoothAdapter.getState() != BluetoothAdapter.STATE_ON)
		{
			try{
				Thread.sleep(1000);
			} catch (Exception e) {
			}
			if (counter > 10)
			{
				return false;
			}
			counter++;
		}

		Set<BluetoothDevice> pairedDevices = _bluetoothAdapter.getBondedDevices();
		if(pairedDevices.size() > 0)
		{
			for(BluetoothDevice device : pairedDevices)
			{
				if (device.getName().startsWith("FireFly-"))
				{
					_bluetoothTarget = device;
					break;
				}
			}
		}
		if (_bluetoothTarget == null) return false;
		if (_bluetoothTarget.getBondState() == BluetoothDevice.BOND_BONDED) return true;
		return false;
	}

	// open the connection
	private void openBT() throws IOException
	{
		if (RobotCommApplication.getInstance().getBluetoothConnected()) return;
		_socket = _bluetoothTarget.createRfcommSocketToServiceRecord(uuid);
		_socket.connect();
		_outputStream = _socket.getOutputStream();
		_inputStream = _socket.getInputStream();
	}
/*
	// send a message to the arduino
	private void sendMessage(BluetoothSocket socket, String msg) {
		OutputStream outStream;
		try {
			outStream = socket.getOutputStream();
			byte[] byteString = (msg + " ").getBytes();
			byteString[byteString.length - 1] = 0;
			outStream.write(byteString);
		} catch (IOException e) {
			Log.d("BLUETOOTH_COMMS", e.getMessage());
		}
	}
*/
	private void ListenForData()
	{
		final Handler handler = new Handler();
		final byte delimiter = 10; //This is the ASCII code for a newline character
		final Context serviceContext = this;

		stopWorker = false;
		readBufferPosition = 0;
		readBuffer = new byte[1024];
		workerThread = new Thread(new Runnable()
		{
			public void run()
			{
				while(!Thread.currentThread().isInterrupted() && !stopWorker)
				{
					try
					{
						int bytesAvailable = _inputStream.available();
						if(bytesAvailable > 0)
						{
							byte[] packetBytes = new byte[bytesAvailable];
							_inputStream.read(packetBytes);
							for(int i=0;i<bytesAvailable;i++)
							{
								byte b = packetBytes[i];
								if(b == delimiter)
								{
									byte[] encodedBytes = new byte[readBufferPosition];
									System.arraycopy(readBuffer, 0, encodedBytes, 0, encodedBytes.length);
									final String data = new String(encodedBytes, "US-ASCII");
									readBufferPosition = 0;
									handler.post(new Runnable()
									{
										public void run()
										{
							        		Intent serviceIntent = new Intent();
							        		serviceIntent.setAction("com.denbar.XMPP_Robot.StartupService");
							        		serviceIntent.putExtra("messageToServer", data);
							        		serviceContext.startService(serviceIntent);
										}
									});
								}
								else
								{
									readBuffer[readBufferPosition++] = b;
								}
							}
						}
					}
					catch (IOException ex)
					{
						stopWorker = true;
					}
				}
			}
		});

		workerThread.start();
	}

    private BroadcastReceiver dataForArduino = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
			String msg = intent.getStringExtra("messageToArduino");
			try {
    			byte[] byteString = (msg + " ").getBytes();
    			byteString[byteString.length - 1] = 0;
    			_outputStream.write(byteString);
    		} catch (IOException e) {
    			Log.d("BLUETOOTH_COMMS", e.getMessage());
    		}
            //Toast.makeText(this, "received", Toast.LENGTH_SHORT,show);

        }
    };

    private BroadcastReceiver bluetoothEvent = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {

        }
    };

	private void closeBT() throws IOException
	{
		stopWorker = true;
		_outputStream.close();
		_inputStream.close();
		_socket.close();
		RobotCommApplication.getInstance().setBluetoothConnected(false);
	}

	@Override
	public IBinder onBind(Intent intent) {

		return null;

	}
}

/*
	private class BluetoothSocketListener implements Runnable {

		private BluetoothSocket socket;
		private Handler handler;

		public BluetoothSocketListener(BluetoothSocket socket,
				Handler handler) {
			this.socket = socket;
			this.handler = handler;
		}

		public void run() {
			int bufferSize = 1024;
			byte[] buffer = new byte[bufferSize];
			try {
				InputStream instream = socket.getInputStream();
				int bytesRead = -1;
				String message = "";
				while (true) {
					message = "";
					bytesRead = instream.read(buffer);
					if (bytesRead != -1) {
						while ((bytesRead==bufferSize)&&(buffer[bufferSize-1] != 0)) {
							message = message + new String(buffer, 0, bytesRead);
							bytesRead = instream.read(buffer);
						}
						message = message + new String(buffer, 0, bytesRead - 1);

						handler.post(new MessagePoster(textView, message));
						socket.getInputStream();
					}
				}
			} catch (IOException e) {
				Log.d("BLUETOOTH_COMMS", e.getMessage());
			}
		}
	}
*/